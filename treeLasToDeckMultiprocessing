#import needed libraries

import pandas as pd

import numpy as np
#import matplotlib.pyplot as plt
import matplotlib.path as mpltPath
#import matplotlib as mpl
#from mpl_toolkits.mplot3d import Axes3D
from scipy.spatial import Voronoi #, voronoi_plot_2d
import os
from datetime import datetime
import json
import laspy
from multiprocessing import Pool

# read tree csv into dataframe
tree_csv = 'csv/2015StreetTreesCensus_TREES.csv'
trees_df_master = pd.read_csv(tree_csv)


def processLas(lasFileName):
    start = datetime.now()
    if lasFileName.endswith('.las'):
        # read las file 
        las = laspy.read('las/{}'.format(lasFileName))
        point_format = las.point_format
        #print(list(point_format.dimension_names))
        lidar_points = np.array((las.X,las.Y,las.Z,las.intensity,las.classification, las.return_number, las.number_of_returns)).transpose()
        lidar_df = pd.DataFrame(lidar_points)
        
        # find bounds of las file
        lidar_df[0] = lidar_df[0]/100
        lidar_df[1] = lidar_df[1]/100
        lidar_df[2] = lidar_df[2]/100
        
        x_min = lidar_df[0].min()
        x_max = lidar_df[0].max()
        y_min = lidar_df[1].min()
        y_max = lidar_df[1].max()
        
        #select trees in lidar footprint
        trees_df = trees_df_master.copy()
        trees_df = trees_df[trees_df['x_sp']>x_min]
        trees_df = trees_df[trees_df['x_sp']<x_max]
        trees_df = trees_df[trees_df['y_sp']>y_min]
        trees_df = trees_df[trees_df['y_sp']<y_max]
        trees_df = trees_df.dropna(axis=0, how='any')
        
        if len(trees_df.index) > 5:
            #convert tree points inside the tile to voronoi polygons with tree's attributes
            def voronoi_funct(input_dataframe):
              df = input_dataframe[['x_sp','y_sp']]
              point_array = df.to_numpy()
              vor = Voronoi(point_array)
              regions = []
              for region in vor.regions:
                  region_points = []
                  for point_index in region:
                      region_points.append((vor.vertices[point_index]).tolist())
                  regions.append(region_points)
              return regions
            
            vor_trees = voronoi_funct(trees_df)
            
            print('trees in tile: ',len(vor_trees))
            
            for vor_tree in vor_trees:
                #convert voronoi region to polygon
                polygon = vor_tree
                if len(polygon) >= 3:
                    path = mpltPath.Path(polygon)
                    
                    lidar_df_2 = lidar_df.copy()
                    trees_df_2 = trees_df.copy()
                    
                    lidar_points = lidar_df[[0,1]]
                    lidar_points = lidar_points.to_numpy()
                    lidar_df_2['inside'] = path.contains_points(lidar_points)
                    lidar_df_2 = lidar_df_2.loc[lidar_df_2.inside, :]
                    
                    tree_stem = trees_df_2[['x_sp','y_sp']]
                    tree_stem = tree_stem.to_numpy()
                    #print(tree_stem)
                    #print('trees in tile: ',len(tree_stem))
                    trees_df_2['inside'] = path.contains_points(tree_stem)
                    #print(trees_df_2['inside'])
                    #print('trees in tile: ',len(trees_df_2['inside']))
                    trees_df_2 = trees_df_2.loc[trees_df_2.inside, :].reset_index()
                    #print(trees_df_2)
                    if len(trees_df_2) == 0:
                        print('bad tree')
                    else:
                        lidar_df_2[0] = lidar_df_2[0] - trees_df_2.iloc[0]['x_sp']
                        lidar_df_2[1] = lidar_df_2[1] - trees_df_2.iloc[0]['y_sp']
                        
                        #canopy extent radius
                        tree_dbh_ft = trees_df_2.iloc[0]['tree_dbh'] / 12
                        tree_dbh_m = tree_dbh_ft / 3.28
                        trunk_area_sq_m = 3.1415926 * ( ( tree_dbh_m / 2 ) ** 2 )
                        canopy_diameter_m = 7 + 28.2 * trunk_area_sq_m
                        canopy_radius_m = canopy_diameter_m / 2
                        canopy_radius = canopy_radius_m * 1.5 * 3.28 #1.5 is margin of error/buffer
                        
                        #distance from trunk filter
                        lidar_df_2 = lidar_df_2[ ( ( lidar_df_2[0]**2 + lidar_df_2[1]**2 ) ** 0.5 ) < canopy_radius ]
                            
                        
                        tree_id = trees_df_2.iloc[0]['tree_id']
                        lidar_df_2.columns = ['X', 'Y', 'Z', 'intens', 'class', 'return_number', 'number_of_returns', 'bool']
                        lidar_df_2 = lidar_df_2.drop(['bool'],axis=1)
                        
                        lidar_df_2['intens'] = (lidar_df_2['intens']-lidar_df_2['intens'].min())/(lidar_df_2['intens'].max()-lidar_df_2['intens'].min())
                        lidar_df_2['intens'] = lidar_df_2['intens'].astype('float')
                        ground_df = lidar_df_2[lidar_df_2['class'].astype(int)==2]
                        lidar_df_2['Z'] = (lidar_df_2['Z'] - ground_df['Z'].mean())/3.28
    
                        lidar_df_2 = lidar_df_2.dropna(axis=0, how='any')
                        #lidar_df_2.to_csv('csv_out/{}.csv'.format(tree_id), float_format='%.4f')
                        lidar_df_3 = lidar_df_2.drop(['class'],axis=1)
                        treeArrayForDeck = lidar_df_3.to_numpy()
                        treeArrayForDeck =  treeArrayForDeck.tolist()
                        with open('csv_out_deck/{}.json'.format(tree_id), 'w', encoding='utf-8') as f:
                            json.dump(treeArrayForDeck, f, ensure_ascii=False)
                        #print('{} records complete'.format(i))
                else:
                    print('polygon only has 2 sides')
        else:
            print('not enough trees in tile')
        end = datetime.now()
        duration = end - start
        duration = duration.total_seconds()
        print(lasFileName, ' complete, tile processed in seconds: ', duration)
    else:
        print('not a las file')
            
        
 
if __name__ == '__main__':
    with Pool() as p:
        p.map(processLas, os.listdir('las/'))
            



